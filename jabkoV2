const { Client, Collection, Events, GatewayIntentBits, Partials, Routes ,REST, EmbedBuilder ,ChannelType} = require("discord.js");
const { joinVoiceChannel, createAudioPlayer, createAudioResource, AudioPlayerStatus } = require('@discordjs/voice');
const { SlashCommandBuilder, ContextMenuCommandBuilder } = require("@discordjs/builders");
const { getAudioUrl } = require('google-tts-api');
const Sequelize = require('sequelize');

const sequelize = new Sequelize('database', 'user', 'password', {
	host: 'localhost',
	dialect: 'sqlite',
	logging: false,
	// SQLite only
	storage: 'database.sqlite',
});

sequelize.authenticate().then(() => {
  console.log('Connection has been established successfully.');
}).catch((error) => {
  console.error('Unable to connect to the database: ', error);
});

const DiscordsServersData = sequelize.define('DiscordsServersData', {
	serverID: { type: Sequelize.TEXT, unique: true, },
  jabkovateID: Sequelize.TEXT,                 // ID mimikovaneho u쬴vatele
  conection:   Sequelize.INTEGER,                 // pointer v map캩 p콏ipojen칤
  jabsay:     Sequelize.BOOLEAN,                  // povolen칳 p콏칤kaz jabsay
  vAFKU:      Sequelize.ARRAY(Sequelize.TEXT), // lidi v AFKu                ??
  zAFKU:      Sequelize.ARRAY(Sequelize.TEXT), // od kud lidi do afku p콏i코li ??
  active:   Sequelize.ARRAY(Sequelize.TEXT), // lidi co n캩kdy byli v akfu na serveru    ??
});

const UserStats = sequelize.define('UserStats', {
	userID: { type: Sequelize.TEXT, unique: true, },
  pocekAFKU: Sequelize.INTEGER,                       // kolikr치t 코el do afku
  pocekAFKUsam: Sequelize.INTEGER,                       // kolikr치t 코el do afku s치m
  pocekOdchoduMeziLidmi: Sequelize.INTEGER,                       // kolikr치t 코el do afku s치m
  casAFKU:   Sequelize.DATE,                       // kolik 캜asu str치vil v afku
  posledniPripojeniAFKu: Sequelize.DATE,              //kdy se p콏ipojil do afku
});

const Vconections = new Map();

sequelize.sync().then(() => {
  console.log('Book table created successfully!');
}).catch((error) => {
  console.error('Unable to create table : ', error);
});

//sequelize.drop();
const client = new Client({
  intents: [GatewayIntentBits.AutoModerationConfiguration, GatewayIntentBits.AutoModerationExecution, GatewayIntentBits.DirectMessageReactions, GatewayIntentBits.DirectMessageTyping, GatewayIntentBits.DirectMessages, GatewayIntentBits.GuildEmojisAndStickers, GatewayIntentBits.GuildIntegrations, GatewayIntentBits.GuildInvites, GatewayIntentBits.GuildMembers, GatewayIntentBits.GuildMessageReactions, GatewayIntentBits.GuildMessageTyping, GatewayIntentBits.GuildMessages, GatewayIntentBits.GuildModeration, GatewayIntentBits.GuildPresences, GatewayIntentBits.GuildScheduledEvents, GatewayIntentBits.GuildVoiceStates, GatewayIntentBits.GuildWebhooks, GatewayIntentBits.Guilds, GatewayIntentBits.MessageContent],
  partials: [Partials.Message, Partials.Channel, Partials.GuildMember, Partials.Reaction, Partials.GuildScheduledEvent, Partials.User, Partials.ThreadMember],
  shards: "auto"
});

/* SYSTEM INFO*/
let token = /*DOPLNIT*/
let appID = /*DOPLNIT*/;


/*-------------------------------------------------------------------------------------------------*/
/*---------------------------------------- Podpurne Funkce ----------------------------------------*/
/*-------------------------------------------------------------------------------------------------*/

async function changeNickName(guild,nickname) {
  var botMember = await guild.members.fetch(client.user.id);
  botMember.setNickname(nickname);
};


function odpoj(guild,INserverID){
  connection = Vconections.get(INserverID);
  changeNickName(guild,"Jable캜n칤k游꼞");  
  if(connection != null){
      connection.destroy();
      connection = null;
  }
  Vconections.set(INserverID,null);
}


// variable that holds commands 
client.commands = new Collection();

// loader function
function addCommand(command){ client.commands.set(command.data.name, command); }

/*-------------------------------------------------------------------------------------------------*/
/*----------------------------------------- Adds commands -----------------------------------------*/
/*-------------------------------------------------------------------------------------------------*/
addCommand({
  data: new SlashCommandBuilder()
      .setName("stats")
      .setDescription("Uk치쬰 ti tvoje statistiky")
      .addBooleanOption(option => option.setName('po코ept치n칤')
        .setDescription('Pokus se styd칤코 tak m콢쬰코 botu nastavit aby ti pouze po코eptal jak neaktivn칤m 캜lenem jsi byl ;)')),
    async execute(interaction) {
      var user = await UserStats.findOne({ where: { userID: interaction.user.id } });

      if(user){
        const banerik = new EmbedBuilder()
        .setColor(0x0099FF)
        .setTitle('Statistika AFKu')
        .setThumbnail(interaction.user.avatarURL({ dynamic:true }))
        .addFields( { name: 'Po캜et AFK콢', value: user.pocekAFKU.toString() , inline: true}, { name: 'zabit칳 캜as', value: (user.casAFKU.getTime()/1000).toFixed(1).toString()+"ms", inline: true }, )
        
        console.log(interaction.options);

        if(interaction.options.getBoolean('po코ept치n칤') ?? false){
          await interaction.reply({ embeds: [banerik] , ephemeral: true});     
        }else{
          await interaction.reply({ embeds: [banerik] });
        }
        
      }else{
        await interaction.reply("Nem치코 쮂멳n칳 z치znam! T_T");
      }

    },
});

addCommand({
  addminCommand: true,
  data: new SlashCommandBuilder()
      .setName("changelog")
      .setDescription("Posledn칤 zm캩ny lmao."),
    async execute(interaction) {
      await interaction.reply('P콏id치no napov칤d치n칤, statistiky a ro쮄뫆솬뗜n칤 pro multiservrovou podporu. v1.2 (HOPE_FINAL).');
    },
});

addCommand({
  addminCommand: true,
  data: new SlashCommandBuilder()
      .setName("mezinas")
      .setDescription("P콏ivol치 jable캜n칤ka do jeho p콏irozen칠ho prost콏ed칤 AFK kan치lu.(pak si ho p콏esun)")
      .addChannelOption(option => option
        .setName('channel')
        .setDescription('c칤lov칳 chanel jable캜n칤ka')
        .addChannelTypes(ChannelType.GuildVoice)
    ),
    async execute(interaction) {
      if(interaction.options.getChannel('channel')){
        var chanel = interaction.options.getChannel('channel').id ;
      }else{
        var chanel = interaction.guild.afkChannelId;
      }

      var server = await DiscordsServersData.findOne({ where: { serverID: interaction.guild.id } });

      // u je n캩kde p콏ipojen칳
      if(Vconections.get(chanel)){
        await interaction.reply('Moment치ln캩 jsem zanepr치zdn캩n칳 v ' + connection.VoiceChannel + ' omluvuju se.');
        return;
      }

      connection = joinVoiceChannel({channelId: chanel, guildId: interaction.guild.id, adapterCreator: interaction.guild.voiceAdapterCreator,selfDeaf: false,selfMute: false});
      Vconections.set(chanel,connection);
      await interaction.reply({content:'U b캩쮂셠.' , ephemeral: true});
    },
});

addCommand({
  addminCommand: true,
  data: new SlashCommandBuilder()
      .setName("upaluj")
      .setDescription("Odvol치코 jable캜n칤ka."),
    async execute(interaction) {
      odpoj(interaction.guild,interaction.guild.id);
      await interaction.reply({content:'U b캩쮂셠.' , ephemeral: true});
    },
});

addCommand({
  addminCommand: true,
  data: new SlashCommandBuilder()
      .setName("best")
      .setDescription("Uk치쬰 stupn캩 nejv캩t코칤ch povale캜콢 na tohoto serveru."),
    async execute(interaction) {
      //vezmeme v코echny lidi na serveru
      const members = await interaction.guild.members.fetch();
      var map = new Map();

      // vyfiltrujeme jen ty co re치ln캩 byli n캩kdy v AFK kan치le
      for (var [key, value] of members) {
        var user = await UserStats.findOne({ where: { userID: key } });
        if(user){
          map.set(key,user.casAFKU.getTime());
        }
      }
      
      // se콏ad칤me od nejvet코칤ho a od콏칤zneme m칤sta 4 a d치l
      const mapSort1 = [...map.entries()].sort((a, b) => b[1] - a[1]).slice(0, 3);

      await interaction.reply({content:'Stupn캩 nejv캩t코칤ch povale캜콢 tad jsou n치sleduj칤c칤:'});
      for (let i = 0; i < 3; i++) {
        // nen칤 dostatek sout캩쮂셖칤ch na prvn칤 3 p콏칤캜ky
        if(mapSort1[i] == undefined){ break; }

        var member = members.get(mapSort1[i][0]);
        const banerik = new EmbedBuilder()
          .setColor(0x0099FF)
          .setTitle('#' + (i + 1)+ ' Prvn칤 m칤sto pat콏칤: ' + member.user.globalName)
          .setThumbnail(member.user.avatarURL())
          .addFields( { name: 'Kter칳 prop치lil v AFKu cel칤ch : ', value: (mapSort1[i][1]/1000).toFixed(2).toString() + " sekund" } )
          .setTimestamp()
        await interaction.channel.send({ embeds: [banerik] });
      }
      
    },
});

addCommand({
  addminCommand: true,
  data: new SlashCommandBuilder()
      .setName("enable_jabsay")
      .setDescription("Nastaven칤 jestli bot p콏ij칤m치 na tomto serveru p콏칤kaz /jabsay.")
      .addBooleanOption(option => option.setName('povolit').setDescription('true -> povoleno v코em : false -> zak치zano na cel칠m serveru pro v코echny').setRequired(true)),
    async execute(interaction) {
      var server = await DiscordsServersData.findOne({ where: { serverID: interaction.guild.id } });
      var jabsay = interaction.options.getBoolean('po코ept치n칤') ?? true;

      server.update({ jabsay: jabsay});

      if(jabsay){
        await interaction.reply({content:'Jabsay bylo zapnuto' , ephemeral: true});
      }else{
        await interaction.reply({content:'Jabsay bylo vypnuto' , ephemeral: true});
      }

    },
});

addCommand({
  data: new SlashCommandBuilder()
      .setName("jabsay")
      .setDescription("Jable캜n칤k r치d vy콏칤d칤 jakoukoli spr치vu tv칳m bratr콢m ve zbrani tak mu ji jen sv캩콏.")
      .addStringOption(option => option.setName('zpr치va') .setDescription('Va코e spr치va k posl치n칤. 캜i k posr치n칤 XD ?').setRequired(true)),
    async execute(interaction) {
      var jabsay_msg = interaction.options.getString('zpr치va') ?? "";

      // o코et콏en칤 chyb
      var server = await DiscordsServersData.findOne({ where: { serverID: interaction.guild.id } });
      if(!server.jabsay){ interaction.reply("P콏칤kaz jabsay nen칤 zapnut칳. \nKontaktujte Mo코ta콏e."); return;}
      var conection = Vconections.get(interaction.guild.id)
      if(conection == null){interaction.reply("A kam to m치m jako mo코tnout?"); return;}

      const audioURL = getAudioUrl(jabsay_msg, {
        lang: 'cs',
        slow: false,
        host: 'https://translate.google.com',
        timeout: 10000,
      });
      
      const resource = createAudioResource(audioURL);
      const player = createAudioPlayer();
      conection.subscribe(player);
      player.play(resource);

      const array = ["Tv치 zpr치va se p콏ehr치v치. Brat콏i ur캜it캩 dychtiv캩 naslouchaj칤 tv칳m slov콢m.", "Oke.", "Jasn칠.", "U to b캩쮂셠 doru캜it.","Ihned tam s t칤m jsem", "Rozkaz 코칠fe"];
      await interaction.reply({content:array[Math.floor(Math.random() * array.length)] , ephemeral: true});
    },
});


/*-------------------------------------------------------------------------------------------------*/
/*-------------------------------------- POdpojovac칤 funkce ---------------------------------------*/
/*-------------------------------------------------------------------------------------------------*/
client.on('voiceStateUpdate', async (oldMember, newMember) => {

  var userID = oldMember.id;

  // ignoruje svoje odpojov치n칤
  if(userID == client.user.id){ return; }

  if(oldMember.channelId != null && oldMember.channelId != undefined){
    var OUTserverID = oldMember.channel.guild.id ;
    var OUTserverAFK = oldMember.channel.guild.afkChannelId;
    var OUTchannelID = oldMember.channel.id ;
  }else{
    var OUTserverID = null;
    var OUTserverAFK = null;
    var OUTchannelID = null;
  }

  if(newMember.channelId != null && newMember.channelId != undefined){
    var INserverID = newMember.channel.guild.id ;
    var INserverAFK = newMember.channel.guild.afkChannelId;
    var INchannelID = newMember.channel.id ;
  }else{
    var INserverAFK = null;
    var INserverID = null;
    var INchannelID = null;
  }

  // mezi kan치ly co nejsou afk (ignorujeme)
  // ------- mimo -> neafk ------------------------------    ---------------------   neafk -> mimo   ------------     ----------------------- neafk -> neafk ---------------------
  if(OUTchannelID == null && (INchannelID != INserverAFK) || (OUTchannelID != OUTserverAFK) && INchannelID == null || (OUTchannelID != OUTserverAFK) && (INchannelID != INserverAFK)){
    console.log(oldMember.member.displayName, " -> ", "mezi kan치ly");
    return;
  }

  const d = new Date();

  // p콏i odpojov치n칤 nebo pipojov치n칤 mu쬰 doj칤t k tomu 쬰 server je 0
  var serverID = INserverID ?? OUTserverID;

  // vyhled치me server (pop콏칤pad캩 vyrob칤me)
  var server = await DiscordsServersData.findOne({ where: { serverID: serverID } });
  if(!server){
    console.log("Server nezn치me vytv치콏칤me datab치zi.");
    server = await DiscordsServersData.create({
      serverID: INserverID,
      jabkovateID: null,
      conection:   null,
      jabsay:      true,
    });
  }

  // vyhled치me u쬴vatele (pop콏칤pad캩 vyrob칤me)
  var user = await UserStats.findOne({ where: { userID: userID } });
  if(!user){
    console.log("U쭀atel se uk치zal poprv칠 vytv치콏칤me datab치zi.");
    user = await UserStats.create({
      userID: userID,
      pocekAFKU: 0,  
      pocekAFKUsam: 0,  //TODO zkontolovat jesli afk je pr치zdn칳          
      casAFKU:   0,
      posledniPripojeniAFKu: null,
    });
  }

  

  // kdy se p콏ipoj칤 do afk a je v datab치zi (pokud nen칤 vytvo콏it a stejn칠 kroky)
    //- zapsat 캜as kdy p콏i코el
    //- p콏idat po캜et afk
    //- p콏idat do fronty na serveru
    //- vlo쬴t jable캜n칤ka
  if((OUTchannelID != OUTserverAFK || OUTchannelID == null ) && INchannelID == INserverAFK){
    console.log(oldMember.member.displayName, " -> ", "코el do afk");

    // aktualizujume hodnoty u쬴vatele v datab치zi
    user.increment('pocekAFKU');
    user.update({ posledniPripojeniAFKu: d.getTime()})

    //change nickname
    var nickname = oldMember.member.nickname;
    if (nickname == null) {  nickname = oldMember.member.user.username; }
    changeNickName(newMember.guild,nickname);

    // connect to channel
    connection = joinVoiceChannel({channelId: oldMember.channelId, guildId: newMember.guild.id, adapterCreator: newMember.guild.voiceAdapterCreator,selfDeaf: false,selfMute: false});

    // generate voice message
    var message = nickname + " zjable캜n캩l."
    const audioURL = getAudioUrl(message, { lang: 'cs', slow: false, host: 'https://translate.google.com', timeout: 10000, });

    //play voice message
    const resource = createAudioResource(audioURL);
    const player = createAudioPlayer();
    connection.subscribe(player);
    player.play(resource);

    // save sesion data
    server.update({ jabkovateID: userID})
    Vconections.set(INserverID,connection);

    return;
  }



  // kdy se odpoj칤 z afk a je v datab치zi
    //- odd캩lat z server que (a pokud je ve front캩 n캩kdo jin칳 tak p콏epsat jm칠no)
      //- pokud byl jedin칳 v server que odd캩lat jable캜n칤ka jinak p콏ejmenovat
    //- p콏i캜칤st afk 캜as a smazat kdy p콏i코el do afku (pokud nen칤 null)
  // kdy se odpoj칤 ale nen칤 v datab치zi (ne콏e코칤me XD)
  if((OUTchannelID == OUTserverAFK && INchannelID != INserverAFK) || (INserverID != OUTserverID && INserverID == null) ){
    console.log(oldMember.member.displayName, " -> ", "코el z afk");

    if(user && user.posledniPripojeniAFKu != null){
      // pokud u쬴vatel neexistuje pouze ho uprav칤me
      user.update({ casAFKU: d.getTime() - user.posledniPripojeniAFKu})
      user.update({ posledniPripojeniAFKu: null})
    }

    if(userID == server.jabkovateID && (Vconections.get(OUTserverID) != null)){ // odpojil se 캜lov캩k z afk
      console.log(oldMember.member.displayName, " -> ", "코el z afk");
      odpoj(oldMember.channel.guild,OUTserverID); 
    }

    return;
  }

  

  console.log("ERROR CASE -!!");
/*

*/

  //OUTserverID -> server ze kter칠ho u쬴vatel p콏i코el
  //INserverID -> server na kter칳 u쬴vatel p콏i코el
  //OUTchannelID -> chanel ze kter칠ho u쬴vatel p콏i코el
  //INchannelID -> chanel na kter칳 u쬴vatel p콏i코el


  
})

/*-------------------------------------------------------------------------------------------------*/
/*---------------------------------------- Handle commands ----------------------------------------*/
/*-------------------------------------------------------------------------------------------------*/
client.on(Events.InteractionCreate, async interaction => {
	if (!interaction.isChatInputCommand()) return;
	const command = interaction.client.commands.get(interaction.commandName);
	if (!command) { console.error(`No command matching ${interaction.commandName} was found.`); return; }

  if(command.addminCommand == true && !(interaction.member.roles.cache.some(role => role.name === 'Mo코ta콏')) ){
    await interaction.reply({ content: 'Na pr치ci s jablky ti chyb칤 v칳u캜n칤 list. B캩 se vzd캩l치vat!', ephemeral: true });
    return;
  }


	try {
		await command.execute(interaction);
	} catch (error) {
		console.error(error);
		if (interaction.replied || interaction.deferred) {
			await interaction.followUp({ content: 'Smutn칳 p콏칤b캩h. Nefunk캜n칤 mo코tov치tko!', ephemeral: true });
		} else {
			await interaction.reply({ content: 'Smutn칳 p콏칤b캩h. Nefunk캜n칤 mo코tov치tko!', ephemeral: true });
		}
	}
});



/*-------------------------------------------------------------------------------------------------*/
/*---------------------------------------- Deploy commands ----------------------------------------*/
/*-------------------------------------------------------------------------------------------------*/
const rest = new REST().setToken(token);

(async () => {
	try {

    // load from map to array for refreshing command snipet
    const commands = [];
    for (const [key, value] of client.commands) {
      commands.push(value.data);
    }

		// The put method is used to fully refresh all commands in the guild with the current set
		const data = await rest.put(
			Routes.applicationCommands(appID),
			{ body: commands },
		);

		console.log(`Successfully reloaded ${data.length} application (/) commands.`);
	} catch (error) {
		// And of course, make sure you catch and log any errors!
		console.error(error);
	}
})();



/*-------------------------------------------------------------------------------------------------*/
/*------------------------------------------- Run client ------------------------------------------*/
/*-------------------------------------------------------------------------------------------------*/
client.on('ready', () => {
  console.log('I am ready!');
  client.user.setActivity("Naslouch치m.", {type: 4})
});

client.login(token);
